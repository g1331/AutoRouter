name: Code-Argus Review

# ============================================================
# SECURITY MODEL:
# This workflow runs code review and publishes results in two jobs.
#
# Job 1 (review): Runs the actual code review
# - Triggered by: pull_request (auto), repository_dispatch (manual re-trigger)
# - Checkouts PR code at pinned SHA
# - Runs Codex review in read-only sandbox
# - Saves results to artifact
#
# Job 2 (publish): Posts review results to PR
# - Runs after review job completes
# - Downloads artifact from review job
# - Posts comments to PR via GitHub API
#
# Related workflows:
# - code-argus-comment.yml: Handles issue_comment, dispatches here
# ============================================================

on:
  pull_request:
    types: [opened, reopened]
  repository_dispatch:
    types: [code-argus-review]

env:
  CODEX_API_KEY: ${{ secrets.CODEX_API_KEY }}
  CODEX_BASE_URL: ${{ secrets.CODEX_BASE_URL }}
  CODEX_MODEL: ${{ vars.CODEX_MODEL }}
  AUGMENT_API_TOKEN: ${{ secrets.AUGMENT_API_TOKEN }}
  AUGMENT_API_URL: ${{ secrets.AUGMENT_API_URL }}

concurrency:
  group: code-argus-${{ github.event.pull_request.number || github.event.client_payload.pr_number || github.run_id }}
  cancel-in-progress: true

# Minimal permissions for review job, publish job needs write access
permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  review:
    name: Review
    runs-on: ubuntu-latest
    outputs:
      pr_number: ${{ steps.context.outputs.pr_number }}
    # For repository_dispatch: trust it (permission already checked by comment workflow)
    # For pull_request: skip bot-triggered events (GitHub Actions bot, Dependabot, etc.)
    if: |
      github.event_name == 'repository_dispatch' ||
      (github.actor != 'github-actions[bot]' &&
       github.actor != 'dependabot[bot]')
    timeout-minutes: 45
    steps:
      # ============================================================
      # Step 1: Determine PR context
      # ============================================================
      - name: Set PR context
        id: context
        uses: actions/github-script@v8
        with:
          script: |
            let prNumber, headSha, baseRef;

            if (context.eventName === 'pull_request') {
              // Direct PR event - use event payload directly (CodeQL approved)
              prNumber = context.payload.pull_request.number;
              headSha = context.payload.pull_request.head.sha;
              baseRef = context.payload.pull_request.base.ref;
            } else if (context.eventName === 'repository_dispatch') {
              // Triggered by comment workflow
              prNumber = context.payload.client_payload.pr_number;
              headSha = context.payload.client_payload.head_sha;
              baseRef = context.payload.client_payload.base_ref;
            }

            if (!prNumber || !headSha || !baseRef) {
              core.setFailed('Missing PR context');
              return;
            }

            // Check if PR is still open (skip review for closed PRs)
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            if (pr.state !== 'open') {
              core.setFailed(`PR #${prNumber} is ${pr.state}, skipping review`);
              return;
            }

            core.setOutput('pr_number', prNumber.toString());
            core.setOutput('head_sha', headSha);
            core.setOutput('base_ref', baseRef);

            console.log(`PR #${prNumber}, SHA: ${headSha}, Base: ${baseRef}`);

      # ============================================================
      # Step 2: Checkout PR code at pinned SHA
      # ============================================================
      - name: Checkout PR at pinned SHA
        uses: actions/checkout@v6
        with:
          # Use immutable SHA reference to prevent TOCTOU attacks
          ref: ${{ steps.context.outputs.head_sha }}
          fetch-depth: 0

      - name: Fetch base branch for diff
        run: git fetch --no-tags origin ${{ steps.context.outputs.base_ref }}

      # ============================================================
      # Step 2.5: Setup MCP servers
      # ============================================================
      - name: Setup Node 22 (for auggie)
        uses: actions/setup-node@v6
        with:
          node-version: 22

      - name: Install auggie CLI
        run: npm install -g @augmentcode/auggie@latest

      - name: Configure Codex MCP servers
        run: |
          python - <<'PY'
          import os
          from pathlib import Path

          config = f"""
          [mcp_servers.auggie-mcp]
          command = "auggie"
          args = ["--mcp"]
          env = {{ AUGMENT_API_TOKEN = "{os.environ['AUGMENT_API_TOKEN']}", AUGMENT_API_URL = "{os.environ['AUGMENT_API_URL']}" }}
          """

          cfg_dir = Path.home() / ".codex"
          cfg_dir.mkdir(parents=True, exist_ok=True)
          (cfg_dir / "config.toml").write_text(config.strip() + "\n", encoding="utf-8")
          PY

      # ============================================================
      # Step 3: Prepare review input
      # ============================================================
      - name: Load config
        id: config
        run: |
          # Use defaults - don't load config from potentially untrusted PR code
          MAX_COMMENTS=10
          MIN_SEVERITY=low
          LANGUAGE=auto
          MODEL="${CODEX_MODEL:-gpt-5.2}"

          echo "max_comments=$MAX_COMMENTS" >> $GITHUB_OUTPUT
          echo "min_severity=$MIN_SEVERITY" >> $GITHUB_OUTPUT
          echo "language=$LANGUAGE" >> $GITHUB_OUTPUT
          echo "model=$MODEL" >> $GITHUB_OUTPUT

      - name: Fetch PR title/body
        uses: actions/github-script@v8
        env:
          PR_NUMBER: ${{ steps.context.outputs.pr_number }}
        with:
          script: |
            const fs = require('fs');
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (!prNumber || Number.isNaN(prNumber)) {
              fs.writeFileSync('/tmp/pr_title.txt', '', 'utf8');
              fs.writeFileSync('/tmp/pr_body.txt', '', 'utf8');
              return;
            }

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            fs.writeFileSync('/tmp/pr_title.txt', pr.title || '', 'utf8');
            fs.writeFileSync('/tmp/pr_body.txt', pr.body || '', 'utf8');

      - name: Prepare prompt file
        run: |
          mkdir -p .github/codex/prompts

          # Generate diff (HEAD is the pinned PR SHA)
          git diff origin/${{ steps.context.outputs.base_ref }}...HEAD > /tmp/pr_diff.txt

          # Generate prompt file
          cat > .github/codex/prompts/review.md << 'PROMPT_EOF'
          # Code-Argus Review Instructions

          You are Code-Argus, an expert code reviewer focused on high-impact issues.

          ## Core Principles

          1. **High signal-to-noise**: Only comment if it would likely change a merge decision
          2. **No style nits**: Never comment on formatting, naming conventions, or subjective preferences
          3. **Actionable feedback**: Every comment must include a concrete fix

          ## Review Focus Areas

          - **Correctness**: Logic errors, edge cases, null handling, race conditions
          - **Security**: XSS, injection, auth bypass, sensitive data exposure
          - **Architecture**: Breaking changes, API compatibility, cross-system impact
          - **Testing**: Missing tests for critical paths, inadequate coverage

          Do NOT comment on:
          - Code style, formatting, or naming conventions
          - Minor optimizations that don't affect functionality
          - Personal preferences or "nice to have" suggestions

          ## Configuration

          PROMPT_EOF

          echo "- Maximum comments: ${{ steps.config.outputs.max_comments }}" >> .github/codex/prompts/review.md
          echo "- Minimum severity: ${{ steps.config.outputs.min_severity }}" >> .github/codex/prompts/review.md
          echo "- Language: ${{ steps.config.outputs.language }} (if 'auto', use the same language as the PR)" >> .github/codex/prompts/review.md
          echo "" >> .github/codex/prompts/review.md

          cat >> .github/codex/prompts/review.md << 'PROMPT_EOF'
          ## Output Format

          Return a JSON object with this exact structure:

          ```json
          {
            "summary": {
              "total_issues": 0,
              "high": 0,
              "medium": 0,
              "low": 0,
              "focus_areas": [],
              "pr_summary": "One-sentence summary of what this PR does",
              "changes": [
                "First major change or feature added",
                "Second major change or feature added"
              ],
              "technical_notes": "Optional technical notes about implementation details, trade-offs, or important considerations (can be empty string if none)"
            },
            "comments": []
          }
          ```

          ### Summary Fields (REQUIRED)
          - `pr_summary`: A concise one-sentence summary of the PR's purpose and impact
          - `changes`: Array of 2-6 bullet points describing the main changes (use imperative mood: "Add...", "Update...", "Fix...")
          - `technical_notes`: Any important technical details reviewers should know (leave empty string if none)

          Each comment in the array should have:
          - `file`: path to the file (e.g., "src/api/routes.ts")
          - `line_start`: starting line number
          - `line_end`: ending line number (same as line_start if single line)
          - `severity`: "high", "medium", or "low"
          - `title`: brief issue title
          - `description`: why this is a problem
          - `suggestion`: the fixed code (will be shown as GitHub suggested change)

          ### CRITICAL: GitHub API Constraints for Inline Comments

          GitHub only allows review comments on lines that are **actually part of the PR diff**. Your comments will FAIL if they violate these rules:

          1. **`file` MUST be a file that appears in the PR diff** (listed in "## PR Diff" section below)
             - Files not modified by this PR cannot receive comments
             - Example: If `.env.example` is not in the diff, you CANNOT comment on it

          2. **`line_start` and `line_end` MUST point to lines with `+` prefix in the diff**
             - These are the NEW/MODIFIED lines in the PR
             - Lines with `-` prefix (deleted lines) or unchanged context lines CANNOT receive comments
             - The line number should be the actual line number in the NEW version of the file

          3. **`suggestion` MUST be valid replacement code for the exact lines specified**
             - It replaces the content from `line_start` to `line_end`
             - Must maintain proper indentation matching the original code

          **If you find an issue in code NOT in the diff:**
          - Do NOT create a comment for it
          - Instead, mention it in `summary.technical_notes` field
          - Example: "Note: Related code in `config.py:45` may also need updating but is outside this PR's scope"

          ## Instructions

          1. You MAY read any file in the repository and run searches to understand context
          2. **IMPORTANT: Use codebase-retrieval for code understanding**
             - Prioritize using `codebase-retrieval` tool to retrieve and understand code context
             - Before analyzing code, use `codebase-retrieval` to get detailed information about:
               - Related classes, methods, and functions
               - Dependencies and imports
               - Usage patterns and call sites
             - Request all relevant symbols in a single call for efficiency
             - Only fall back to file reading if `codebase-retrieval` is unavailable
          3. Review ONLY the changes in this PR (diff provided below); comments MUST target lines within the diff
          4. Sort issues by severity (high first), then limit to max_comments
          5. If language is 'auto', respond in the same language as the PR title/description
          6. If no significant issues found, return empty comments array
          7. Output ONLY the JSON object, no other text
          8. VERIFY each comment's file and line are in the diff before including it

          ## PR Information

          PROMPT_EOF

          echo -n "**Title**: " >> .github/codex/prompts/review.md
          cat /tmp/pr_title.txt >> .github/codex/prompts/review.md
          echo "" >> .github/codex/prompts/review.md
          echo "**Description**:" >> .github/codex/prompts/review.md
          cat /tmp/pr_body.txt >> .github/codex/prompts/review.md
          echo "" >> .github/codex/prompts/review.md
          echo "## PR Diff" >> .github/codex/prompts/review.md
          echo "" >> .github/codex/prompts/review.md
          echo '```diff' >> .github/codex/prompts/review.md
          cat /tmp/pr_diff.txt >> .github/codex/prompts/review.md
          echo '```' >> .github/codex/prompts/review.md

      # ============================================================
      # Step 4: Run Code-Argus Review
      # ============================================================
      - name: Run Code-Argus
        id: review
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.CODEX_API_KEY }}
          responses-api-endpoint: ${{ secrets.CODEX_BASE_URL }}/responses
          model: ${{ steps.config.outputs.model }}
          effort: xhigh
          sandbox: read-only
          prompt-file: .github/codex/prompts/review.md
          # Allow bots for repository_dispatch (triggered by comment workflow as github-actions[bot])
          allow-bots: ${{ github.event_name == 'repository_dispatch' }}
          # MCP server is configured via ~/.codex/config.toml (see "Configure Codex MCP servers" step)
          output-schema: |
            {
              "type": "object",
              "properties": {
                "summary": {
                  "type": "object",
                  "properties": {
                    "total_issues": { "type": "integer" },
                    "high": { "type": "integer" },
                    "medium": { "type": "integer" },
                    "low": { "type": "integer" },
                    "focus_areas": { "type": "array", "items": { "type": "string" } },
                    "pr_summary": { "type": "string" },
                    "changes": { "type": "array", "items": { "type": "string" } },
                    "technical_notes": { "type": "string" }
                  },
                  "required": ["total_issues", "high", "medium", "low", "focus_areas", "pr_summary", "changes", "technical_notes"],
                  "additionalProperties": false
                },
                "comments": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "file": { "type": "string" },
                      "line_start": { "type": "integer" },
                      "line_end": { "type": "integer" },
                      "severity": { "type": "string", "enum": ["high", "medium", "low"] },
                      "title": { "type": "string" },
                      "description": { "type": "string" },
                      "suggestion": { "type": "string" }
                    },
                    "required": ["file", "line_start", "line_end", "severity", "title", "description", "suggestion"],
                    "additionalProperties": false
                  }
                }
              },
              "required": ["summary", "comments"],
              "additionalProperties": false
            }

      # ============================================================
      # Step 5: Save results as artifact for publish workflow
      # ============================================================
      - name: Save review results
        env:
          PR_NUMBER: ${{ steps.context.outputs.pr_number }}
          HEAD_SHA: ${{ steps.context.outputs.head_sha }}
          REVIEW_OUTPUT: ${{ steps.review.outputs.final-message }}
        run: |
          mkdir -p /tmp/review-results
          echo "$PR_NUMBER" > /tmp/review-results/pr_number.txt
          echo "$HEAD_SHA" > /tmp/review-results/head_sha.txt
          echo "$REVIEW_OUTPUT" > /tmp/review-results/review_output.json

      - name: Upload review artifact
        uses: actions/upload-artifact@v7
        with:
          name: code-argus-review-${{ steps.context.outputs.pr_number }}
          path: /tmp/review-results/
          retention-days: 1

  # ============================================================
  # Publish Job: Post review results to PR
  # ============================================================
  publish:
    name: Publish Results
    runs-on: ubuntu-latest
    needs: review
    if: always() && needs.review.result == 'success'
    steps:
      - name: Download review artifact
        uses: actions/download-artifact@v7
        with:
          name: code-argus-review-${{ needs.review.outputs.pr_number }}
          path: /tmp/review-results

      - name: Read artifact contents
        id: artifact
        run: |
          PR_NUMBER=$(cat /tmp/review-results/pr_number.txt)
          HEAD_SHA=$(cat /tmp/review-results/head_sha.txt)
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "head_sha=$HEAD_SHA" >> $GITHUB_OUTPUT

      - name: Post review
        uses: actions/github-script@v8
        env:
          PR_NUMBER: ${{ steps.artifact.outputs.pr_number }}
          HEAD_SHA: ${{ steps.artifact.outputs.head_sha }}
          REVIEW_RESULT: ${{ needs.review.result }}
        with:
          script: |
            const fs = require('fs');
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            const headSha = process.env.HEAD_SHA;
            const reviewResult = process.env.REVIEW_RESULT;

            if (!prNumber || Number.isNaN(prNumber)) {
              console.log('Invalid PR number');
              return;
            }

            // Handle failed review
            if (reviewResult !== 'success') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `## Code-Argus Review\n\n‚ùå Review failed. Please check the [workflow logs](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) for details.\n\nComment \`code-argus review\` to retry.`
              });
              return;
            }

            // Read review output
            let output;
            try {
              output = fs.readFileSync('/tmp/review-results/review_output.json', 'utf8');
            } catch (e) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `## Code-Argus Review\n\n‚ùå No output received from review service.\n\nComment \`code-argus review\` to retry.`
              });
              return;
            }

            if (!output || output.trim() === '') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `## Code-Argus Review\n\n‚ùå Empty output from review service.\n\nComment \`code-argus review\` to retry.`
              });
              return;
            }

            // Parse review output
            let review;
            try {
              review = JSON.parse(output.trim());
            } catch (directParseError) {
              try {
                const jsonMatch = output.match(/\{[\s\S]*"summary"[\s\S]*"comments"[\s\S]*\}(?=[^}]*$)/);
                if (!jsonMatch) {
                  throw new Error('No JSON object found');
                }
                review = JSON.parse(jsonMatch[0]);
              } catch (extractError) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `## Code-Argus Review\n\n‚ùå Failed to parse review output.\n\nComment \`code-argus review\` to retry.`
                });
                return;
              }
            }

            const severityEmoji = { high: 'üî¥', medium: 'üü°', low: 'üü¢' };

            // Generate PR Summary section
            let prSummarySection = '';
            if (review.summary) {
              const s = review.summary;
              prSummarySection = `<details open>\n<summary>ü§ñ <strong>Code-Argus PR Summary</strong></summary>\n\n`;

              if (s.pr_summary) {
                prSummarySection += `**Summary**: ${s.pr_summary}\n\n`;
              }

              if (s.changes && s.changes.length > 0) {
                prSummarySection += `**Changes**:\n`;
                for (const change of s.changes) {
                  prSummarySection += `- ${change}\n`;
                }
                prSummarySection += `\n`;
              }

              if (s.technical_notes && s.technical_notes.trim() !== '') {
                prSummarySection += `**Technical Notes**: ${s.technical_notes}\n\n`;
              }

              prSummarySection += `ü§ñ Was this summary useful? React with üëç or üëé\n`;
              prSummarySection += `</details>\n\n---\n\n`;
            }

            // Prepare review comments
            const reviewComments = [];
            if (review.comments && review.comments.length > 0) {
              for (const comment of review.comments) {
                const emoji = severityEmoji[comment.severity] || 'üü°';
                let body = `## ${emoji} [${comment.severity.toUpperCase()}] ${comment.title}\n\n`;
                body += `${comment.description}\n\n`;

                if (comment.suggestion) {
                  body += '```suggestion\n';
                  body += comment.suggestion;
                  if (!comment.suggestion.endsWith('\n')) body += '\n';
                  body += '```\n';
                }

                const lineEnd = comment.line_end || comment.line_start;
                const reviewComment = {
                  path: comment.file,
                  line: lineEnd,
                  side: 'RIGHT',
                  body
                };

                if (comment.line_start && comment.line_end && comment.line_start !== comment.line_end) {
                  reviewComment.start_line = comment.line_start;
                  reviewComment.start_side = 'RIGHT';
                }

                reviewComments.push(reviewComment);
              }
            }

            // Generate summary
            const summary = review.summary || { total_issues: 0, high: 0, medium: 0, low: 0, focus_areas: [] };
            let summaryBody = prSummarySection;
            summaryBody += `## Code-Argus Review\n\n`;

            if (summary.total_issues === 0) {
              summaryBody += `‚úÖ Review completed. **No significant issues found.**\n\n`;
              summaryBody += `The changes look good from a correctness, security, and architecture perspective.\n`;
            } else {
              summaryBody += `Review completed. **${summary.total_issues}** issue(s) found.\n\n`;
              summaryBody += `| Severity | Count |\n`;
              summaryBody += `|----------|-------|\n`;
              if (summary.high > 0) summaryBody += `| üî¥ High | ${summary.high} |\n`;
              if (summary.medium > 0) summaryBody += `| üü° Medium | ${summary.medium} |\n`;
              if (summary.low > 0) summaryBody += `| üü¢ Low | ${summary.low} |\n`;

              if (summary.focus_areas && summary.focus_areas.length > 0) {
                summaryBody += `\n**Focus areas**: ${summary.focus_areas.join(', ')}\n`;
              }

              summaryBody += `\n---\n`;
              summaryBody += `üí° **Tip**: Comment the following to trigger auto-fix:\n`;
              summaryBody += `\`\`\`\n@autorouter-bot ËØ∑Ê†πÊçÆ‰∏äÊñπ Code-Argus review ÂèçÈ¶à‰øÆÂ§ç‰ª£Á†ÅÈóÆÈ¢ò\n\`\`\`\n`;
            }

            summaryBody += `\n---\n`;
            summaryBody += `Comment \`code-argus review\` to re-trigger review.`;

            // Post the review
            let reviewCreated = false;

            try {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                commit_id: headSha,
                event: 'COMMENT',
                body: summaryBody,
                comments: reviewComments.length > 0 ? reviewComments : undefined
              });
              reviewCreated = true;
            } catch (e) {
              console.log(`Failed to create review with inline comments: ${e.message}`);
            }

            // Fallback: post summary and comments separately
            if (!reviewCreated) {
              try {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  commit_id: headSha,
                  event: 'COMMENT',
                  body: summaryBody
                });
                reviewCreated = true;
              } catch (e) {
                console.log(`Failed to create summary review: ${e.message}`);
              }

              // Post inline comments individually
              if (reviewComments.length > 0) {
                for (const comment of reviewComments) {
                  try {
                    await github.rest.pulls.createReviewComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber,
                      commit_id: headSha,
                      path: comment.path,
                      line: comment.line,
                      side: comment.side,
                      start_line: comment.start_line,
                      start_side: comment.start_side,
                      body: comment.body
                    });
                  } catch (e) {
                    console.log(`Failed to post comment on ${comment.path}:${comment.line}: ${e.message}`);
                  }
                }
              }

              // Last resort: post as issue comment
              if (!reviewCreated) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: summaryBody
                });
              }
            }

            console.log('Review published successfully');
