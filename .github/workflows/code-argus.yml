name: Code-Argus Review

on:
  pull_request:
    types: [opened, reopened]
  issue_comment:
    types: [created]

env:
  CODEX_API_KEY: ${{ secrets.CODEX_API_KEY }}
  CODEX_BASE_URL: ${{ secrets.CODEX_BASE_URL }}
  CODEX_MODEL: ${{ vars.CODEX_MODEL }}

concurrency:
  group: code-argus-${{ github.event.pull_request.number || github.event.issue.number || github.run_id }}
  cancel-in-progress: true

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  prepare:
    name: Prepare
    runs-on: ubuntu-latest
    # PR è‡ªåŠ¨è§¦å‘ æˆ– PR è¯„è®ºä¸­åŒ…å«è§¦å‘å…³é”®è¯ï¼ˆæŽ’é™¤ bot ç”¨æˆ·é¿å…å¾ªçŽ¯è§¦å‘ï¼‰
    if: |
      github.actor != 'github-actions[bot]' &&
      (github.event_name == 'pull_request' ||
       (github.event.issue.pull_request &&
        (contains(github.event.comment.body, 'code-argus review') ||
         contains(github.event.comment.body, 'argus review') ||
         contains(github.event.comment.body, 'code-argus å®¡æŸ¥'))))

    outputs:
      allowed: ${{ steps.check_perm.outputs.allowed }}
      pr_number: ${{ steps.prmeta.outputs.number }}
      base_ref: ${{ steps.prmeta.outputs.base_ref }}

    steps:
      # ============================================================
      # Step 1: æƒé™æ£€æŸ¥ - ä»… collaborators å¯è§¦å‘
      # ============================================================
      - name: Check permissions
        id: check_perm
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { data } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: context.actor
              });
              const allowed = ['admin', 'write'].includes(data.permission);
              core.setOutput('allowed', allowed);
              if (!allowed) {
                console.log(`User ${context.actor} has ${data.permission} permission, skipping review`);
              }
              return allowed;
            } catch (error) {
              console.log(`Permission check failed: ${error.message}`);
              core.setOutput('allowed', false);
              return false;
            }

      - name: Add reaction to trigger comment
        if: steps.check_perm.outputs.allowed == 'true' && github.event_name == 'issue_comment'
        uses: actions/github-script@v7
        with:
          script: |
            try {
              await github.rest.reactions.createForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: context.payload.comment.id,
                content: 'eyes'
              });
            } catch (error) {
              console.log(`Failed to add reaction: ${error.message}`);
            }

      - name: Get PR metadata
        if: steps.check_perm.outputs.allowed == 'true'
        id: prmeta
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request?.number ?? context.payload.issue?.number;
            if (!prNumber) {
              core.setOutput('number', '');
              core.setOutput('base_ref', '');
              return;
            }

            // pull_request äº‹ä»¶å¯ç›´æŽ¥æ‹¿åˆ° base.refï¼›issue_comment äº‹ä»¶éœ€è¦é¢å¤–æŸ¥è¯¢
            let baseRef = context.payload.pull_request?.base?.ref;
            if (!baseRef) {
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              baseRef = pr.base.ref;
            }

            core.setOutput('number', prNumber.toString());
            core.setOutput('base_ref', baseRef || '');

  agent:
    name: Agent
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.allowed == 'true'
    timeout-minutes: 45

    outputs:
      review_output: ${{ steps.review.outputs.final-message }}

    steps:
      # ============================================================
      # Step 2: Checkout PR ä»£ç 
      # ============================================================
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch PR refs
        run: |
          git fetch --no-tags origin ${{ needs.prepare.outputs.base_ref }}
          git fetch --no-tags origin +refs/pull/${{ needs.prepare.outputs.pr_number }}/head:refs/remotes/origin/pr-head

      - name: Checkout PR head
        run: git checkout origin/pr-head

      # ============================================================
      # Step 3: å‡†å¤‡ Review è¾“å…¥
      # ============================================================
      - name: Load config
        id: config
        run: |
          MAX_COMMENTS=10
          MIN_SEVERITY=low
          LANGUAGE=auto
          MODEL="${CODEX_MODEL:-gpt-5.2}"

          if [ -f ".github/reviewbot.yaml" ]; then
            if command -v yq &> /dev/null; then
              MAX_COMMENTS=$(yq '.max_comments // 10' .github/reviewbot.yaml)
              MIN_SEVERITY=$(yq '.min_severity // "low"' .github/reviewbot.yaml)
              LANGUAGE=$(yq '.language // "auto"' .github/reviewbot.yaml)
            fi
          fi

          echo "max_comments=$MAX_COMMENTS" >> $GITHUB_OUTPUT
          echo "min_severity=$MIN_SEVERITY" >> $GITHUB_OUTPUT
          echo "language=$LANGUAGE" >> $GITHUB_OUTPUT
          echo "model=$MODEL" >> $GITHUB_OUTPUT

      - name: Fetch PR title/body
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ needs.prepare.outputs.pr_number }}
        with:
          script: |
            const fs = require('fs');
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (!prNumber || Number.isNaN(prNumber)) {
              fs.writeFileSync('/tmp/pr_title.txt', '', 'utf8');
              fs.writeFileSync('/tmp/pr_body.txt', '', 'utf8');
              return;
            }

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            fs.writeFileSync('/tmp/pr_title.txt', pr.title || '', 'utf8');
            fs.writeFileSync('/tmp/pr_body.txt', pr.body || '', 'utf8');

      - name: Prepare prompt file
        run: |
          mkdir -p .github/codex/prompts

          # èŽ·å– diff å¹¶ä¿å­˜åˆ°ä¸´æ—¶æ–‡ä»¶ï¼ˆé¿å… shell å˜é‡é•¿åº¦é™åˆ¶ï¼‰
          git diff origin/${{ needs.prepare.outputs.base_ref }}...origin/pr-head > /tmp/pr_diff.txt

          # ç”Ÿæˆ prompt æ–‡ä»¶
          cat > .github/codex/prompts/review.md << 'PROMPT_EOF'
          # Code-Argus Review Instructions

          You are Code-Argus, an expert code reviewer focused on high-impact issues.

          ## Core Principles

          1. **High signal-to-noise**: Only comment if it would likely change a merge decision
          2. **No style nits**: Never comment on formatting, naming conventions, or subjective preferences
          3. **Actionable feedback**: Every comment must include a concrete fix

          ## Review Focus Areas

          - **Correctness**: Logic errors, edge cases, null handling, race conditions
          - **Security**: XSS, injection, auth bypass, sensitive data exposure
          - **Architecture**: Breaking changes, API compatibility, cross-system impact
          - **Testing**: Missing tests for critical paths, inadequate coverage

          Do NOT comment on:
          - Code style, formatting, or naming conventions
          - Minor optimizations that don't affect functionality
          - Personal preferences or "nice to have" suggestions

          ## Configuration

          PROMPT_EOF

          echo "- Maximum comments: ${{ steps.config.outputs.max_comments }}" >> .github/codex/prompts/review.md
          echo "- Minimum severity: ${{ steps.config.outputs.min_severity }}" >> .github/codex/prompts/review.md
          echo "- Language: ${{ steps.config.outputs.language }} (if 'auto', use the same language as the PR)" >> .github/codex/prompts/review.md
          echo "" >> .github/codex/prompts/review.md

          cat >> .github/codex/prompts/review.md << 'PROMPT_EOF'
          ## Output Format

          Return a JSON object with this exact structure:

          ```json
          {
            "summary": {
              "total_issues": 0,
              "high": 0,
              "medium": 0,
              "low": 0,
              "focus_areas": []
            },
            "comments": []
          }
          ```

          Each comment in the array should have:
          - `file`: path to the file (e.g., "src/api/routes.ts")
          - `line_start`: starting line number
          - `line_end`: ending line number (same as line_start if single line)
          - `severity`: "high", "medium", or "low"
          - `title`: brief issue title
          - `description`: why this is a problem
          - `suggestion`: the fixed code (will be shown as GitHub suggested change)

          ## Instructions

          1. You MAY read any file in the repository and run searches to understand context
          2. Review ONLY the changes in this PR (diff provided below); use other files only for context and impact verification
          3. Sort issues by severity (high first), then limit to max_comments
          4. If language is 'auto', respond in the same language as the PR title/description
          5. If no significant issues found, return empty comments array
          6. Output ONLY the JSON object, no other text

          ## PR Information

          PROMPT_EOF

          echo -n "**Title**: " >> .github/codex/prompts/review.md
          cat /tmp/pr_title.txt >> .github/codex/prompts/review.md
          echo "" >> .github/codex/prompts/review.md
          echo "**Description**:" >> .github/codex/prompts/review.md
          cat /tmp/pr_body.txt >> .github/codex/prompts/review.md
          echo "" >> .github/codex/prompts/review.md
          echo "## PR Diff" >> .github/codex/prompts/review.md
          echo "" >> .github/codex/prompts/review.md
          echo '```diff' >> .github/codex/prompts/review.md
          cat /tmp/pr_diff.txt >> .github/codex/prompts/review.md
          echo '```' >> .github/codex/prompts/review.md

      # ============================================================
      # Step 4: è¿è¡Œ Code-Argus Review (ä½¿ç”¨å®˜æ–¹ Action)
      # ============================================================
      - name: Run Code-Argus
        id: review
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.CODEX_API_KEY }}
          # CODEX_BASE_URL æ ¼å¼: https://xxx.com/v1ï¼Œéœ€è¦åŠ  /responses
          responses-api-endpoint: ${{ secrets.CODEX_BASE_URL }}/responses
          model: ${{ steps.config.outputs.model }}
          effort: xhigh
          sandbox: read-only
          prompt-file: .github/codex/prompts/review.md
          output-schema: |
            {
              "type": "object",
              "properties": {
                "summary": {
                  "type": "object",
                  "properties": {
                    "total_issues": { "type": "integer" },
                    "high": { "type": "integer" },
                    "medium": { "type": "integer" },
                    "low": { "type": "integer" },
                    "focus_areas": { "type": "array", "items": { "type": "string" } }
                  },
                  "required": ["total_issues", "high", "medium", "low", "focus_areas"],
                  "additionalProperties": false
                },
                "comments": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "file": { "type": "string" },
                      "line_start": { "type": "integer" },
                      "line_end": { "type": "integer" },
                      "severity": { "type": "string", "enum": ["high", "medium", "low"] },
                      "title": { "type": "string" },
                      "description": { "type": "string" },
                      "suggestion": { "type": "string" }
                    },
                    "required": ["file", "line_start", "line_end", "severity", "title", "description", "suggestion"],
                    "additionalProperties": false
                  }
                }
              },
              "required": ["summary", "comments"],
              "additionalProperties": false
            }

  publish:
    name: Publish
    runs-on: ubuntu-latest
    needs: [prepare, agent]
    if: needs.prepare.outputs.allowed == 'true' && always()

    steps:
      - name: Post review comments
        uses: actions/github-script@v7
        env:
          REVIEW_OUTPUT: ${{ needs.agent.outputs.review_output }}
          PR_NUMBER: ${{ needs.prepare.outputs.pr_number }}
          AGENT_RESULT: ${{ needs.agent.result }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (!prNumber || Number.isNaN(prNumber)) return;

            const agentResult = process.env.AGENT_RESULT || '';
            const output = process.env.REVIEW_OUTPUT || '';

            if (agentResult !== 'success') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `## Code-Argus Review\n\nâŒ Review failed. Please check the [workflow logs](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) for details.\n\nComment \`code-argus review\` to retry.`
              });
              return;
            }

            console.log('Raw output length:', output.length);
            console.log('Raw output (first 500 chars):', output.slice(0, 500));

            // æ£€æŸ¥æ˜¯å¦ä¸ºç©ºè¾“å‡º
            if (!output || output.trim() === '') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `## Code-Argus Review\n\nâŒ No output received from review service.\n\nPlease check the [workflow logs](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) for details.\n\nComment \`code-argus review\` to retry.`
              });
              return;
            }

            let review;

            try {
              // å®˜æ–¹ Action ä½¿ç”¨ output-schema æ—¶ï¼Œfinal-message åº”è¯¥ç›´æŽ¥æ˜¯å¹²å‡€çš„ JSON
              review = JSON.parse(output.trim());
              console.log('Parsed review directly:', JSON.stringify(review.summary));
            } catch (directParseError) {
              console.log('Direct JSON parse failed:', directParseError.message);

              // å¦‚æžœç›´æŽ¥è§£æžå¤±è´¥ï¼Œå°è¯•æå– JSON
              try {
                let jsonStr = null;

                // Method 1: Find the last complete JSON object in the output
                const jsonMatch = output.match(/\{[\s\S]*"summary"[\s\S]*"comments"[\s\S]*\}(?=[^}]*$)/);
                if (jsonMatch) {
                  jsonStr = jsonMatch[0];
                }

                // Method 2: Find JSON after "codex" marker
                if (!jsonStr) {
                  const codexMarkerIndex = output.lastIndexOf('codex\n');
                  if (codexMarkerIndex > -1) {
                    const afterCodex = output.substring(codexMarkerIndex + 6).trim();
                    const jsonStartIndex = afterCodex.indexOf('{');
                    if (jsonStartIndex > -1) {
                      let braceCount = 0;
                      let jsonEndIndex = -1;
                      for (let i = jsonStartIndex; i < afterCodex.length; i++) {
                        if (afterCodex[i] === '{') braceCount++;
                        if (afterCodex[i] === '}') braceCount--;
                        if (braceCount === 0) {
                          jsonEndIndex = i + 1;
                          break;
                        }
                      }
                      if (jsonEndIndex > jsonStartIndex) {
                        jsonStr = afterCodex.substring(jsonStartIndex, jsonEndIndex);
                      }
                    }
                  }
                }

                if (!jsonStr) {
                  throw new Error('No JSON object found in output');
                }

                console.log('Found JSON string length:', jsonStr.length);
                review = JSON.parse(jsonStr);
                console.log('Parsed review from extraction:', JSON.stringify(review.summary));
              } catch (extractError) {
                console.log('JSON extraction failed:', extractError.message);
                console.log('Raw output (last 2000 chars):', output.slice(-2000));
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `## Code-Argus Review\n\nâŒ Failed to parse review output.\n\nPlease check the [workflow logs](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) for details.\n\nComment \`code-argus review\` to retry.`
                });
                return;
              }
            }

            const severityEmoji = { high: 'ðŸ”´', medium: 'ðŸŸ¡', low: 'ðŸŸ¢' };

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            const commitSha = pr.head.sha;

            const reviewComments = [];
            if (review.comments && review.comments.length > 0) {
              for (const comment of review.comments) {
                const emoji = severityEmoji[comment.severity] || 'ðŸŸ¡';
                let body = `## ${emoji} [${comment.severity.toUpperCase()}] ${comment.title}\n\n`;
                body += `${comment.description}\n\n`;

                if (comment.suggestion) {
                  body += '```suggestion\n';
                  body += comment.suggestion;
                  if (!comment.suggestion.endsWith('\n')) body += '\n';
                  body += '```\n';
                }

                const lineEnd = comment.line_end || comment.line_start;
                const reviewComment = {
                  path: comment.file,
                  line: lineEnd,
                  side: 'RIGHT',
                  body
                };

                if (comment.line_start && comment.line_end && comment.line_start !== comment.line_end) {
                  reviewComment.start_line = comment.line_start;
                  reviewComment.start_side = 'RIGHT';
                }

                reviewComments.push(reviewComment);
              }
            }

            // ç”Ÿæˆå¹¶æäº¤ PR Reviewï¼ˆå¸¦æ€»ç»“ + è¡Œå†…è¯„è®ºï¼‰
            const summary = review.summary || { total_issues: 0, high: 0, medium: 0, low: 0, focus_areas: [] };
            let summaryBody = `## Code-Argus Review\n\n`;

            if (summary.total_issues === 0) {
              summaryBody += `Review completed. **No significant issues found.**\n\n`;
              summaryBody += `The changes look good from a correctness, security, and architecture perspective.\n`;
            } else {
              summaryBody += `Review completed. **${summary.total_issues}** suggestion(s) posted.\n\n`;
              summaryBody += `| Severity | Count |\n`;
              summaryBody += `|----------|-------|\n`;
              if (summary.high > 0) summaryBody += `| ðŸ”´ High | ${summary.high} |\n`;
              if (summary.medium > 0) summaryBody += `| ðŸŸ¡ Medium | ${summary.medium} |\n`;
              if (summary.low > 0) summaryBody += `| ðŸŸ¢ Low | ${summary.low} |\n`;

              if (summary.focus_areas && summary.focus_areas.length > 0) {
                summaryBody += `\n**Focus areas**: ${summary.focus_areas.join(', ')}\n`;
              }
            }

            summaryBody += `\n---\n`;
            summaryBody += `Comment \`code-argus review\` to re-trigger review`;

            let reviewCreated = false;

            try {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                commit_id: commitSha,
                event: 'COMMENT',
                body: summaryBody,
                comments: reviewComments.length > 0 ? reviewComments : undefined
              });
              reviewCreated = true;
            } catch (e) {
              console.log(`Failed to create review with inline comments: ${e.message}`);
            }

            if (!reviewCreated) {
              try {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  commit_id: commitSha,
                  event: 'COMMENT',
                  body: summaryBody
                });
                reviewCreated = true;
              } catch (e) {
                console.log(`Failed to create summary review: ${e.message}`);
              }

              if (reviewComments.length > 0) {
                for (const comment of reviewComments) {
                  try {
                    await github.rest.pulls.createReviewComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber,
                      commit_id: commitSha,
                      path: comment.path,
                      line: comment.line,
                      side: comment.side,
                      start_line: comment.start_line,
                      start_side: comment.start_side,
                      body: comment.body
                    });
                  } catch (e) {
                    console.log(`Failed to post comment on ${comment.path}:${comment.line}: ${e.message}`);
                  }
                }
              }

              if (!reviewCreated) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: summaryBody
                });
              }
            }
