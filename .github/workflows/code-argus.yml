name: Code-Argus Review

on:
  pull_request:
    types: [opened, reopened]
  issue_comment:
    types: [created]

env:
  CODEX_API_KEY: ${{ secrets.CODEX_API_KEY }}
  CODEX_BASE_URL: ${{ secrets.CODEX_BASE_URL }}
  CODEX_MODEL: ${{ vars.CODEX_MODEL }}

concurrency:
  group: code-argus-${{ github.event.pull_request.number || github.event.issue.number || github.run_id }}
  cancel-in-progress: true

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  prepare:
    name: Prepare
    runs-on: ubuntu-latest
    # PR Ëá™Âä®Ëß¶Âèë Êàñ PR ËØÑËÆ∫‰∏≠ÂåÖÂê´Ëß¶ÂèëÂÖ≥ÈîÆËØçÔºàÊéíÈô§ bot Áî®Êà∑Âíå @autorouter-bot Ëß¶ÂèëÈÅøÂÖçÂÜ≤Á™ÅÔºâ
    if: |
      github.actor != 'github-actions[bot]' &&
      (github.event_name == 'pull_request' ||
       (github.event.issue.pull_request &&
        !contains(github.event.comment.body, '@autorouter-bot') &&
        (contains(github.event.comment.body, 'code-argus review') ||
         contains(github.event.comment.body, 'argus review') ||
         contains(github.event.comment.body, 'code-argus ÂÆ°Êü•'))))

    outputs:
      allowed: ${{ steps.check_perm.outputs.allowed }}
      pr_number: ${{ steps.prmeta.outputs.number }}
      base_ref: ${{ steps.prmeta.outputs.base_ref }}

    steps:
      # ============================================================
      # Step 1: ÊùÉÈôêÊ£ÄÊü• - ‰ªÖ collaborators ÂèØËß¶Âèë
      # ============================================================
      - name: Check permissions
        id: check_perm
        uses: actions/github-script@v7
        with:
          script: |
            try {
              const { data } = await github.rest.repos.getCollaboratorPermissionLevel({
                owner: context.repo.owner,
                repo: context.repo.repo,
                username: context.actor
              });
              const allowed = ['admin', 'write'].includes(data.permission);
              core.setOutput('allowed', allowed);
              if (!allowed) {
                console.log(`User ${context.actor} has ${data.permission} permission, skipping review`);
              }
              return allowed;
            } catch (error) {
              console.log(`Permission check failed: ${error.message}`);
              core.setOutput('allowed', false);
              return false;
            }

      - name: Add reaction to trigger comment
        if: steps.check_perm.outputs.allowed == 'true' && github.event_name == 'issue_comment'
        uses: actions/github-script@v7
        with:
          script: |
            try {
              await github.rest.reactions.createForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: context.payload.comment.id,
                content: 'eyes'
              });
            } catch (error) {
              console.log(`Failed to add reaction: ${error.message}`);
            }

      - name: Get PR metadata
        if: steps.check_perm.outputs.allowed == 'true'
        id: prmeta
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = context.payload.pull_request?.number ?? context.payload.issue?.number;

            if (!prNumber) {
              core.setOutput('number', '');
              core.setOutput('base_ref', '');
              return;
            }

            // pull_request ‰∫ã‰ª∂ÂèØÁõ¥Êé•ÊãøÂà∞ base.refÔºõissue_comment ‰∫ã‰ª∂ÈúÄË¶ÅÈ¢ùÂ§ñÊü•ËØ¢
            let baseRef = context.payload.pull_request?.base?.ref;
            if (!baseRef) {
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });
              baseRef = pr.base.ref;
            }

            core.setOutput('number', prNumber.toString());
            core.setOutput('base_ref', baseRef || '');

  review:
    name: Review
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.allowed == 'true'
    timeout-minutes: 45

    outputs:
      review_output: ${{ steps.review.outputs.final-message }}

    steps:
      # ============================================================
      # Step 2: Checkout PR ‰ª£Á†Å
      # ============================================================
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch PR refs
        run: |
          git fetch --no-tags origin ${{ needs.prepare.outputs.base_ref }}
          git fetch --no-tags origin +refs/pull/${{ needs.prepare.outputs.pr_number }}/head:refs/remotes/origin/pr-head

      - name: Checkout PR head
        run: git checkout origin/pr-head

      # ============================================================
      # Step 3: ÂáÜÂ§á Review ËæìÂÖ•
      # ============================================================
      - name: Load config
        id: config
        run: |
          MAX_COMMENTS=10
          MIN_SEVERITY=low
          LANGUAGE=auto
          MODEL="${CODEX_MODEL:-gpt-5.2}"

          if [ -f ".github/reviewbot.yaml" ]; then
            if command -v yq &> /dev/null; then
              MAX_COMMENTS=$(yq '.max_comments // 10' .github/reviewbot.yaml)
              MIN_SEVERITY=$(yq '.min_severity // "low"' .github/reviewbot.yaml)
              LANGUAGE=$(yq '.language // "auto"' .github/reviewbot.yaml)
            fi
          fi

          echo "max_comments=$MAX_COMMENTS" >> $GITHUB_OUTPUT
          echo "min_severity=$MIN_SEVERITY" >> $GITHUB_OUTPUT
          echo "language=$LANGUAGE" >> $GITHUB_OUTPUT
          echo "model=$MODEL" >> $GITHUB_OUTPUT

      - name: Fetch PR title/body
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ needs.prepare.outputs.pr_number }}
        with:
          script: |
            const fs = require('fs');
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (!prNumber || Number.isNaN(prNumber)) {
              fs.writeFileSync('/tmp/pr_title.txt', '', 'utf8');
              fs.writeFileSync('/tmp/pr_body.txt', '', 'utf8');
              return;
            }

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });

            fs.writeFileSync('/tmp/pr_title.txt', pr.title || '', 'utf8');
            fs.writeFileSync('/tmp/pr_body.txt', pr.body || '', 'utf8');

      - name: Prepare prompt file
        run: |
          mkdir -p .github/codex/prompts

          # Ëé∑Âèñ diff Âπ∂‰øùÂ≠òÂà∞‰∏¥Êó∂Êñá‰ª∂ÔºàÈÅøÂÖç shell ÂèòÈáèÈïøÂ∫¶ÈôêÂà∂Ôºâ
          git diff origin/${{ needs.prepare.outputs.base_ref }}...origin/pr-head > /tmp/pr_diff.txt

          # ÁîüÊàê prompt Êñá‰ª∂
          cat > .github/codex/prompts/review.md << 'PROMPT_EOF'
          # Code-Argus Review Instructions

          You are Code-Argus, an expert code reviewer focused on high-impact issues.

          ## Core Principles

          1. **High signal-to-noise**: Only comment if it would likely change a merge decision
          2. **No style nits**: Never comment on formatting, naming conventions, or subjective preferences
          3. **Actionable feedback**: Every comment must include a concrete fix

          ## Review Focus Areas

          - **Correctness**: Logic errors, edge cases, null handling, race conditions
          - **Security**: XSS, injection, auth bypass, sensitive data exposure
          - **Architecture**: Breaking changes, API compatibility, cross-system impact
          - **Testing**: Missing tests for critical paths, inadequate coverage

          Do NOT comment on:
          - Code style, formatting, or naming conventions
          - Minor optimizations that don't affect functionality
          - Personal preferences or "nice to have" suggestions

          ## Configuration

          PROMPT_EOF

          echo "- Maximum comments: ${{ steps.config.outputs.max_comments }}" >> .github/codex/prompts/review.md
          echo "- Minimum severity: ${{ steps.config.outputs.min_severity }}" >> .github/codex/prompts/review.md
          echo "- Language: ${{ steps.config.outputs.language }} (if 'auto', use the same language as the PR)" >> .github/codex/prompts/review.md
          echo "" >> .github/codex/prompts/review.md

          cat >> .github/codex/prompts/review.md << 'PROMPT_EOF'
          ## Output Format

          Return a JSON object with this exact structure:

          ```json
          {
            "summary": {
              "total_issues": 0,
              "high": 0,
              "medium": 0,
              "low": 0,
              "focus_areas": [],
              "pr_summary": "One-sentence summary of what this PR does",
              "changes": [
                "First major change or feature added",
                "Second major change or feature added"
              ],
              "technical_notes": "Optional technical notes about implementation details, trade-offs, or important considerations (can be empty string if none)"
            },
            "comments": []
          }
          ```

          ### Summary Fields (REQUIRED)
          - `pr_summary`: A concise one-sentence summary of the PR's purpose and impact
          - `changes`: Array of 2-6 bullet points describing the main changes (use imperative mood: "Add...", "Update...", "Fix...")
          - `technical_notes`: Any important technical details reviewers should know (leave empty string if none)

          Each comment in the array should have:
          - `file`: path to the file (e.g., "src/api/routes.ts")
          - `line_start`: starting line number
          - `line_end`: ending line number (same as line_start if single line)
          - `severity`: "high", "medium", or "low"
          - `title`: brief issue title
          - `description`: why this is a problem
          - `suggestion`: the fixed code (will be shown as GitHub suggested change)

          ## Instructions

          1. You MAY read any file in the repository and run searches to understand context
          2. Review ONLY the changes in this PR (diff provided below); use other files only for context and impact verification
          3. Sort issues by severity (high first), then limit to max_comments
          4. If language is 'auto', respond in the same language as the PR title/description
          5. If no significant issues found, return empty comments array
          6. Output ONLY the JSON object, no other text

          ## PR Information

          PROMPT_EOF

          echo -n "**Title**: " >> .github/codex/prompts/review.md
          cat /tmp/pr_title.txt >> .github/codex/prompts/review.md
          echo "" >> .github/codex/prompts/review.md
          echo "**Description**:" >> .github/codex/prompts/review.md
          cat /tmp/pr_body.txt >> .github/codex/prompts/review.md
          echo "" >> .github/codex/prompts/review.md
          echo "## PR Diff" >> .github/codex/prompts/review.md
          echo "" >> .github/codex/prompts/review.md
          echo '```diff' >> .github/codex/prompts/review.md
          cat /tmp/pr_diff.txt >> .github/codex/prompts/review.md
          echo '```' >> .github/codex/prompts/review.md

      # ============================================================
      # Step 4: ËøêË°å Code-Argus Review (‰ΩøÁî®ÂÆòÊñπ Action)
      # ============================================================
      - name: Run Code-Argus
        id: review
        uses: openai/codex-action@v1
        with:
          openai-api-key: ${{ secrets.CODEX_API_KEY }}
          # CODEX_BASE_URL Ê†ºÂºè: https://xxx.com/v1ÔºåÈúÄË¶ÅÂä† /responses
          responses-api-endpoint: ${{ secrets.CODEX_BASE_URL }}/responses
          model: ${{ steps.config.outputs.model }}
          effort: xhigh
          sandbox: read-only
          prompt-file: .github/codex/prompts/review.md
          output-schema: |
            {
              "type": "object",
              "properties": {
                "summary": {
                  "type": "object",
                  "properties": {
                    "total_issues": { "type": "integer" },
                    "high": { "type": "integer" },
                    "medium": { "type": "integer" },
                    "low": { "type": "integer" },
                    "focus_areas": { "type": "array", "items": { "type": "string" } },
                    "pr_summary": { "type": "string" },
                    "changes": { "type": "array", "items": { "type": "string" } },
                    "technical_notes": { "type": "string" }
                  },
                  "required": ["total_issues", "high", "medium", "low", "focus_areas", "pr_summary", "changes", "technical_notes"],
                  "additionalProperties": false
                },
                "comments": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "file": { "type": "string" },
                      "line_start": { "type": "integer" },
                      "line_end": { "type": "integer" },
                      "severity": { "type": "string", "enum": ["high", "medium", "low"] },
                      "title": { "type": "string" },
                      "description": { "type": "string" },
                      "suggestion": { "type": "string" }
                    },
                    "required": ["file", "line_start", "line_end", "severity", "title", "description", "suggestion"],
                    "additionalProperties": false
                  }
                }
              },
              "required": ["summary", "comments"],
              "additionalProperties": false
            }

  publish:
    name: Publish
    runs-on: ubuntu-latest
    needs: [prepare, review]
    if: needs.prepare.outputs.allowed == 'true' && always()

    steps:
      - name: Post review comments
        uses: actions/github-script@v7
        env:
          REVIEW_OUTPUT: ${{ needs.review.outputs.review_output }}
          PR_NUMBER: ${{ needs.prepare.outputs.pr_number }}
          REVIEW_RESULT: ${{ needs.review.result }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            if (!prNumber || Number.isNaN(prNumber)) return;

            const reviewResult = process.env.REVIEW_RESULT || '';
            const output = process.env.REVIEW_OUTPUT || '';

            if (reviewResult !== 'success') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `## Code-Argus Review\n\n‚ùå Review failed. Please check the [workflow logs](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}) for details.\n\nComment \`code-argus review\` to retry.`
              });
              return;
            }

            // Ê£ÄÊü•ÊòØÂê¶‰∏∫Á©∫ËæìÂá∫
            if (!output || output.trim() === '') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `## Code-Argus Review\n\n‚ùå No output received from review service.\n\nComment \`code-argus review\` to retry.`
              });
              return;
            }

            let review;

            try {
              review = JSON.parse(output.trim());
            } catch (directParseError) {
              try {
                let jsonStr = null;
                const jsonMatch = output.match(/\{[\s\S]*"summary"[\s\S]*"comments"[\s\S]*\}(?=[^}]*$)/);
                if (jsonMatch) {
                  jsonStr = jsonMatch[0];
                }
                if (!jsonStr) {
                  throw new Error('No JSON object found in output');
                }
                review = JSON.parse(jsonStr);
              } catch (extractError) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `## Code-Argus Review\n\n‚ùå Failed to parse review output.\n\nComment \`code-argus review\` to retry.`
                });
                return;
              }
            }

            const severityEmoji = { high: 'üî¥', medium: 'üü°', low: 'üü¢' };

            // ÁîüÊàê PR Summary ÈÉ®ÂàÜÔºàÂèØÊäòÂè†Ôºâ
            let prSummarySection = '';
            if (review.summary) {
              const s = review.summary;
              prSummarySection = `<details open>\n<summary>ü§ñ <strong>Code-Argus PR Summary</strong></summary>\n\n`;

              if (s.pr_summary) {
                prSummarySection += `**Summary**: ${s.pr_summary}\n\n`;
              }

              if (s.changes && s.changes.length > 0) {
                prSummarySection += `**Changes**:\n`;
                for (const change of s.changes) {
                  prSummarySection += `- ${change}\n`;
                }
                prSummarySection += `\n`;
              }

              if (s.technical_notes && s.technical_notes.trim() !== '') {
                prSummarySection += `**Technical Notes**: ${s.technical_notes}\n\n`;
              }

              prSummarySection += `ü§ñ Was this summary useful? React with üëç or üëé\n`;
              prSummarySection += `</details>\n\n---\n\n`;
            }

            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber
            });
            const commitSha = pr.head.sha;

            const reviewComments = [];
            if (review.comments && review.comments.length > 0) {
              for (const comment of review.comments) {
                const emoji = severityEmoji[comment.severity] || 'üü°';
                let body = `## ${emoji} [${comment.severity.toUpperCase()}] ${comment.title}\n\n`;
                body += `${comment.description}\n\n`;

                if (comment.suggestion) {
                  body += '```suggestion\n';
                  body += comment.suggestion;
                  if (!comment.suggestion.endsWith('\n')) body += '\n';
                  body += '```\n';
                }

                const lineEnd = comment.line_end || comment.line_start;
                const reviewComment = {
                  path: comment.file,
                  line: lineEnd,
                  side: 'RIGHT',
                  body
                };

                if (comment.line_start && comment.line_end && comment.line_start !== comment.line_end) {
                  reviewComment.start_line = comment.line_start;
                  reviewComment.start_side = 'RIGHT';
                }

                reviewComments.push(reviewComment);
              }
            }

            // ÁîüÊàêÊÄªÁªì
            const summary = review.summary || { total_issues: 0, high: 0, medium: 0, low: 0, focus_areas: [] };
            let summaryBody = prSummarySection;  // ÂÖàÊ∑ªÂä† PR Summary
            summaryBody += `## Code-Argus Review\n\n`;

            if (summary.total_issues === 0) {
              summaryBody += `‚úÖ Review completed. **No significant issues found.**\n\n`;
              summaryBody += `The changes look good from a correctness, security, and architecture perspective.\n`;
            } else {
              summaryBody += `Review completed. **${summary.total_issues}** issue(s) found.\n\n`;
              summaryBody += `| Severity | Count |\n`;
              summaryBody += `|----------|-------|\n`;
              if (summary.high > 0) summaryBody += `| üî¥ High | ${summary.high} |\n`;
              if (summary.medium > 0) summaryBody += `| üü° Medium | ${summary.medium} |\n`;
              if (summary.low > 0) summaryBody += `| üü¢ Low | ${summary.low} |\n`;

              if (summary.focus_areas && summary.focus_areas.length > 0) {
                summaryBody += `\n**Focus areas**: ${summary.focus_areas.join(', ')}\n`;
              }

              // Ê∑ªÂä†Ëá™Âä®‰øÆÂ§çÊèêÁ§∫
              summaryBody += `\n---\n`;
              summaryBody += `üí° **Tip**: Comment the following to trigger auto-fix:\n`;
              summaryBody += `\`\`\`\n@autorouter-bot ËØ∑Ê†πÊçÆ‰∏äÊñπ Code-Argus review ÂèçÈ¶à‰øÆÂ§ç‰ª£Á†ÅÈóÆÈ¢ò\n\`\`\`\n`;
            }

            summaryBody += `\n---\n`;
            summaryBody += `Comment \`code-argus review\` to re-trigger review.`;

            // Êèê‰∫§ Review
            let reviewCreated = false;

            try {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                commit_id: commitSha,
                event: 'COMMENT',
                body: summaryBody,
                comments: reviewComments.length > 0 ? reviewComments : undefined
              });
              reviewCreated = true;
            } catch (e) {
              console.log(`Failed to create review with inline comments: ${e.message}`);
            }

            if (!reviewCreated) {
              try {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  commit_id: commitSha,
                  event: 'COMMENT',
                  body: summaryBody
                });
                reviewCreated = true;
              } catch (e) {
                console.log(`Failed to create summary review: ${e.message}`);
              }

              if (reviewComments.length > 0) {
                for (const comment of reviewComments) {
                  try {
                    await github.rest.pulls.createReviewComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber,
                      commit_id: commitSha,
                      path: comment.path,
                      line: comment.line,
                      side: comment.side,
                      start_line: comment.start_line,
                      start_side: comment.start_side,
                      body: comment.body
                    });
                  } catch (e) {
                    console.log(`Failed to post comment on ${comment.path}:${comment.line}: ${e.message}`);
                  }
                }
              }

              if (!reviewCreated) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: summaryBody
                });
              }
            }
