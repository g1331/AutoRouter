name: Code-Argus Publish

# ============================================================
# SECURITY MODEL:
# This workflow runs in a privileged context (has write permissions)
# but NEVER checks out untrusted code. It only:
# 1. Downloads artifacts from the review workflow
# 2. Posts comments to the PR via GitHub API
#
# This is the "privileged" part of the workflow_run pattern.
# ============================================================

on:
  workflow_run:
    workflows: ["Code-Argus Review"]
    types: [completed]

permissions:
  contents: read
  issues: write
  pull-requests: write

jobs:
  publish:
    name: Publish Results
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion != 'cancelled'

    steps:
      # ============================================================
      # Step 1: Download review artifact
      # ============================================================
      - name: Download review artifact
        uses: actions/github-script@v8
        id: download
        with:
          script: |
            const fs = require('fs');

            // List artifacts from the triggering workflow run
            const artifacts = await github.rest.actions.listWorkflowRunArtifacts({
              owner: context.repo.owner,
              repo: context.repo.repo,
              run_id: context.payload.workflow_run.id
            });

            // Find the review artifact
            const reviewArtifact = artifacts.data.artifacts.find(
              a => a.name.startsWith('code-argus-review-')
            );

            if (!reviewArtifact) {
              console.log('No review artifact found');
              core.setOutput('found', 'false');
              return;
            }

            // Download the artifact
            const download = await github.rest.actions.downloadArtifact({
              owner: context.repo.owner,
              repo: context.repo.repo,
              artifact_id: reviewArtifact.id,
              archive_format: 'zip'
            });

            fs.writeFileSync('/tmp/review-artifact.zip', Buffer.from(download.data));
            core.setOutput('found', 'true');
            console.log(`Downloaded artifact: ${reviewArtifact.name}`);

      - name: Extract artifact
        if: steps.download.outputs.found == 'true'
        run: |
          mkdir -p /tmp/review-results
          unzip -o /tmp/review-artifact.zip -d /tmp/review-results

      - name: Read artifact contents
        if: steps.download.outputs.found == 'true'
        id: artifact
        run: |
          PR_NUMBER=$(cat /tmp/review-results/pr_number.txt)
          HEAD_SHA=$(cat /tmp/review-results/head_sha.txt)
          echo "pr_number=$PR_NUMBER" >> $GITHUB_OUTPUT
          echo "head_sha=$HEAD_SHA" >> $GITHUB_OUTPUT

      # ============================================================
      # Step 2: Post review comments
      # ============================================================
      - name: Post review
        if: steps.download.outputs.found == 'true'
        uses: actions/github-script@v8
        env:
          PR_NUMBER: ${{ steps.artifact.outputs.pr_number }}
          HEAD_SHA: ${{ steps.artifact.outputs.head_sha }}
          WORKFLOW_CONCLUSION: ${{ github.event.workflow_run.conclusion }}
          WORKFLOW_RUN_ID: ${{ github.event.workflow_run.id }}
        with:
          script: |
            const fs = require('fs');
            const prNumber = parseInt(process.env.PR_NUMBER, 10);
            const headSha = process.env.HEAD_SHA;
            const conclusion = process.env.WORKFLOW_CONCLUSION;
            const runId = process.env.WORKFLOW_RUN_ID;

            if (!prNumber || Number.isNaN(prNumber)) {
              console.log('Invalid PR number');
              return;
            }

            // Handle failed workflow
            if (conclusion !== 'success') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `## Code-Argus Review\n\n‚ùå Review failed. Please check the [workflow logs](https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${runId}) for details.\n\nComment \`code-argus review\` to retry.`
              });
              return;
            }

            // Read review output
            let output;
            try {
              output = fs.readFileSync('/tmp/review-results/review_output.json', 'utf8');
            } catch (e) {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `## Code-Argus Review\n\n‚ùå No output received from review service.\n\nComment \`code-argus review\` to retry.`
              });
              return;
            }

            if (!output || output.trim() === '') {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `## Code-Argus Review\n\n‚ùå Empty output from review service.\n\nComment \`code-argus review\` to retry.`
              });
              return;
            }

            // Parse review output
            let review;
            try {
              review = JSON.parse(output.trim());
            } catch (directParseError) {
              try {
                const jsonMatch = output.match(/\{[\s\S]*"summary"[\s\S]*"comments"[\s\S]*\}(?=[^}]*$)/);
                if (!jsonMatch) {
                  throw new Error('No JSON object found');
                }
                review = JSON.parse(jsonMatch[0]);
              } catch (extractError) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `## Code-Argus Review\n\n‚ùå Failed to parse review output.\n\nComment \`code-argus review\` to retry.`
                });
                return;
              }
            }

            const severityEmoji = { high: 'üî¥', medium: 'üü°', low: 'üü¢' };

            // Generate PR Summary section
            let prSummarySection = '';
            if (review.summary) {
              const s = review.summary;
              prSummarySection = `<details open>\n<summary>ü§ñ <strong>Code-Argus PR Summary</strong></summary>\n\n`;

              if (s.pr_summary) {
                prSummarySection += `**Summary**: ${s.pr_summary}\n\n`;
              }

              if (s.changes && s.changes.length > 0) {
                prSummarySection += `**Changes**:\n`;
                for (const change of s.changes) {
                  prSummarySection += `- ${change}\n`;
                }
                prSummarySection += `\n`;
              }

              if (s.technical_notes && s.technical_notes.trim() !== '') {
                prSummarySection += `**Technical Notes**: ${s.technical_notes}\n\n`;
              }

              prSummarySection += `ü§ñ Was this summary useful? React with üëç or üëé\n`;
              prSummarySection += `</details>\n\n---\n\n`;
            }

            // Prepare review comments
            const reviewComments = [];
            if (review.comments && review.comments.length > 0) {
              for (const comment of review.comments) {
                const emoji = severityEmoji[comment.severity] || 'üü°';
                let body = `## ${emoji} [${comment.severity.toUpperCase()}] ${comment.title}\n\n`;
                body += `${comment.description}\n\n`;

                if (comment.suggestion) {
                  body += '```suggestion\n';
                  body += comment.suggestion;
                  if (!comment.suggestion.endsWith('\n')) body += '\n';
                  body += '```\n';
                }

                const lineEnd = comment.line_end || comment.line_start;
                const reviewComment = {
                  path: comment.file,
                  line: lineEnd,
                  side: 'RIGHT',
                  body
                };

                if (comment.line_start && comment.line_end && comment.line_start !== comment.line_end) {
                  reviewComment.start_line = comment.line_start;
                  reviewComment.start_side = 'RIGHT';
                }

                reviewComments.push(reviewComment);
              }
            }

            // Generate summary
            const summary = review.summary || { total_issues: 0, high: 0, medium: 0, low: 0, focus_areas: [] };
            let summaryBody = prSummarySection;
            summaryBody += `## Code-Argus Review\n\n`;

            if (summary.total_issues === 0) {
              summaryBody += `‚úÖ Review completed. **No significant issues found.**\n\n`;
              summaryBody += `The changes look good from a correctness, security, and architecture perspective.\n`;
            } else {
              summaryBody += `Review completed. **${summary.total_issues}** issue(s) found.\n\n`;
              summaryBody += `| Severity | Count |\n`;
              summaryBody += `|----------|-------|\n`;
              if (summary.high > 0) summaryBody += `| üî¥ High | ${summary.high} |\n`;
              if (summary.medium > 0) summaryBody += `| üü° Medium | ${summary.medium} |\n`;
              if (summary.low > 0) summaryBody += `| üü¢ Low | ${summary.low} |\n`;

              if (summary.focus_areas && summary.focus_areas.length > 0) {
                summaryBody += `\n**Focus areas**: ${summary.focus_areas.join(', ')}\n`;
              }

              summaryBody += `\n---\n`;
              summaryBody += `üí° **Tip**: Comment the following to trigger auto-fix:\n`;
              summaryBody += `\`\`\`\n@autorouter-bot ËØ∑Ê†πÊçÆ‰∏äÊñπ Code-Argus review ÂèçÈ¶à‰øÆÂ§ç‰ª£Á†ÅÈóÆÈ¢ò\n\`\`\`\n`;
            }

            summaryBody += `\n---\n`;
            summaryBody += `Comment \`code-argus review\` to re-trigger review.`;

            // Post the review
            let reviewCreated = false;

            try {
              await github.rest.pulls.createReview({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber,
                commit_id: headSha,
                event: 'COMMENT',
                body: summaryBody,
                comments: reviewComments.length > 0 ? reviewComments : undefined
              });
              reviewCreated = true;
            } catch (e) {
              console.log(`Failed to create review with inline comments: ${e.message}`);
            }

            // Fallback: post summary and comments separately
            if (!reviewCreated) {
              try {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  commit_id: headSha,
                  event: 'COMMENT',
                  body: summaryBody
                });
                reviewCreated = true;
              } catch (e) {
                console.log(`Failed to create summary review: ${e.message}`);
              }

              // Post inline comments individually
              if (reviewComments.length > 0) {
                for (const comment of reviewComments) {
                  try {
                    await github.rest.pulls.createReviewComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      pull_number: prNumber,
                      commit_id: headSha,
                      path: comment.path,
                      line: comment.line,
                      side: comment.side,
                      start_line: comment.start_line,
                      start_side: comment.start_side,
                      body: comment.body
                    });
                  } catch (e) {
                    console.log(`Failed to post comment on ${comment.path}:${comment.line}: ${e.message}`);
                  }
                }
              }

              // Last resort: post as issue comment
              if (!reviewCreated) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: summaryBody
                });
              }
            }

            console.log('Review published successfully');

      # ============================================================
      # Step 3: Handle case where no artifact was found
      # ============================================================
      - name: Handle missing artifact
        if: steps.download.outputs.found != 'true' && github.event.workflow_run.conclusion == 'success'
        uses: actions/github-script@v8
        env:
          WORKFLOW_RUN_ID: ${{ github.event.workflow_run.id }}
        with:
          script: |
            console.log('Review workflow completed but no artifact found');
            // This could happen if the review was skipped (e.g., permissions denied)
            // We don't post anything in this case as it's expected behavior
